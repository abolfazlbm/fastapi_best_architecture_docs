import{_ as e,c as s,e as a,o as t}from"./app-BmTAx6X_.js";const l={};function n(p,i){return t(),s("div",null,i[0]||(i[0]=[a(`<p>我们在 fba 中为数据库主键添加了两种选择，分别为传统模式（自增 ID）和雪花算法（雪花 ID），<mark class="note">我们在全局范围内使用自增 ID 作为主键的默认声明方式</mark></p><p>在切换主键声明方式之前，让我们先来简单了解一下它们的特性，再决定是否需要切换</p><h2 id="自增-id" tabindex="-1"><a class="header-anchor" href="#自增-id"><span>自增 ID</span></a></h2><ul><li><p>优点</p><p>简单易用，数据库（如MySQL）原生支持，生成顺序递增，查询效率高，占用空间小</p></li><li><p>局限性</p><p>在分布式系统中可能出现 ID 冲突，扩展性较差；ID 生成依赖数据库，性能瓶颈风险较高；ID 可预测，可能暴露业务数据量或存在安全隐患</p></li></ul><h2 id="雪花-id" tabindex="-1"><a class="header-anchor" href="#雪花-id"><span>雪花 ID</span></a></h2><ul><li><p>优点</p><p>分布式环境友好，ID 全局唯一且无需依赖中央数据库；包含时间戳，生成 ID 天然有序，便于排序和查询</p></li><li><p>局限性</p><p>实现复杂，需额外维护生成器；可能因时间回拨（如服务器时钟同步问题）导致无法新增数据；ID 长度较长，存储和传输成本略高</p></li></ul><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h2><ul><li><p>自增 ID</p><p>单机或中小规模应用，业务简单且对 ID 可预测性无敏感</p></li><li><p>雪花 ID</p><p>如果是分布式系统、微服务架构，或需要高并发、跨地域生成唯一 ID</p></li></ul><h2 id="切换选择" tabindex="-1"><a class="header-anchor" href="#切换选择"><span>切换选择</span></a></h2><ul><li><p>自增 ID</p><p>无需切换，这是 fba 内的全局默认声明方式</p></li><li><p>雪花 ID</p><ol><li>更新 fba 内所有 sqlalchemy model 中的 <code>id: Mapped[id_key]</code> 为 <code>id: Mapped[snowflake_id_key]</code></li><li>更新所有 <code>id_key</code> 导入为 <code>snowflake_id_key</code></li><li>执行 <code>backend/sql/init_snowflake_test_data.sql</code> 脚本初始化测试数据</li></ol><div class="hint-container caution"><p class="hint-container-title">Windows 平台警告</p><p>如果您正在 Windows 平台中使用 mysql &gt;= 8.0，还需要更新 <code>backend/database/db.py</code> 文件内的 <code>mysql+asyncmy</code> 为 <code>mysql+aiomysql</code>，否则，您将无法在本地正常新增数据。相关 issue：<a href="https://github.com/long2ice/asyncmy/issues/35" target="_blank" rel="noopener noreferrer">asyncmy/issues/35</a></p></div></li></ul><h2 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h2><ul><li><p>使用雪花 ID 时，需确保时钟同步（如通过 NTP）和节点 ID 的唯一性分配</p></li><li><p>传统自增 ID 在数据迁移或合并时需特别注意冲突问题</p></li><li><p><mark class="danger">前端渲染长整数偏移</mark></p><p>当后端 api 返回长整数时，返回结果是没有问题的，但是通过前端组件渲染为 table 等数据之后，可能导致长整数渲染错误。</p><p>通过控制台可以发现，数据 id 与返回数据不一致，最佳解决方法是：后端将长整数序列化为字符串之后再返回，例如：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-dark:#abb2bf;--shiki-light:#383A42;--shiki-dark-bg:#282c34;--shiki-light-bg:#FAFAFA;"><pre class="shiki shiki-themes one-dark-pro one-light vp-code"><code class="language-python"><span class="line"><span style="--shiki-dark:#7F848E;--shiki-dark-font-style:italic;--shiki-light:#A0A1A7;--shiki-light-font-style:italic;"># 在所有定义返回数据的 schema 中添加字段序列化器</span></span>
<span class="line"><span style="--shiki-dark:#61AFEF;--shiki-light:#4078F2;">@field_serializer</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">(</span><span style="--shiki-dark:#98C379;--shiki-light:#50A14F;">&quot;id&quot;</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">)</span></span>
<span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">def</span><span style="--shiki-dark:#61AFEF;--shiki-light:#4078F2;"> serialize_id</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">(</span><span style="--shiki-dark:#E5C07B;--shiki-dark-font-style:italic;--shiki-light:#986801;--shiki-light-font-style:inherit;">self</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">,</span><span style="--shiki-dark:#D19A66;--shiki-dark-font-style:italic;--shiki-light:#986801;--shiki-light-font-style:inherit;"> value</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">) -&gt; </span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;">str</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">:</span></span>
<span class="line"><span style="--shiki-dark:#C678DD;--shiki-light:#A626A4;">    return</span><span style="--shiki-dark:#56B6C2;--shiki-light:#0184BC;"> str</span><span style="--shiki-dark:#ABB2BF;--shiki-light:#383A42;">(value)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,12)]))}const d=e(l,[["render",n]]),h=JSON.parse('{"path":"/backend/reference/pk.html","title":"主键","lang":"zh-CN","frontmatter":{"title":"主键","description":"我们在 fba 中为数据库主键添加了两种选择，分别为传统模式（自增 ID）和雪花算法（雪花 ID），我们在全局范围内使用自增 ID 作为主键的默认声明方式 在切换主键声明方式之前，让我们先来简单了解一下它们的特性，再决定是否需要切换 自增 ID 优点 简单易用，数据库（如MySQL）原生支持，生成顺序递增，查询效率高，占用空间小 局限性 在分布式系统中...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"主键\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://fastapi-practices.github.io/fastapi_best_architecture_docs/fastapi_best_architecture_docs/backend/reference/pk.html"}],["meta",{"property":"og:site_name","content":"FastAPI Best Architecture"}],["meta",{"property":"og:title","content":"主键"}],["meta",{"property":"og:description","content":"我们在 fba 中为数据库主键添加了两种选择，分别为传统模式（自增 ID）和雪花算法（雪花 ID），我们在全局范围内使用自增 ID 作为主键的默认声明方式 在切换主键声明方式之前，让我们先来简单了解一下它们的特性，再决定是否需要切换 自增 ID 优点 简单易用，数据库（如MySQL）原生支持，生成顺序递增，查询效率高，占用空间小 局限性 在分布式系统中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"readingTime":{"minutes":2.22,"words":665},"git":{"createdTime":1750009202000},"autoDesc":true,"filePathRelative":"backend/reference/pk.md","headers":[],"categoryList":[{"id":"b43fdd","sort":10000,"name":"backend"},{"id":"4b6340","sort":10002,"name":"reference"}],"bulletin":true}');export{d as comp,h as data};
